---
title: "Compresión del audio"
author: "Javier Herrero Pérez"
date: "2025-12-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Compresión del audio


```{r}
# Librerías
library(av)
library(wavelets)
library(tuneR)
library(RColorBrewer)
```



```{r}
# Parámetros
n.levels <- 3
lambda <- 0.2

audio <- readWave("data/audio.wav")

source("funciones_audio.R",echo=F)

# DWT + threshold
vals <- dwt_values(audio, n.levels, lambda)

# Cuantización
q_left  <- vals$thr_left
q_right <- vals$thr_right

# Codificación
enc_left  <- encode_wt(q_left)
enc_right <- encode_wt(q_right)

# Guardar archivo comprimido
size_bytes <- save_compressed(
  "data_comp/audio_wavelet_comp.rds",
  left  = enc_left,
  right = enc_right,
  filter = "la8",
  n.levels = n.levels
)

cat("Tamaño del archivo comprimido:", size_bytes/1024, "KB\n")

```
### Decodificación

```{r}

wt_left_rec <- decode_wt(enc_left, vals$thr_left)

wt_right_rec <- decode_wt(enc_right, vals$thr_right)

# Señal final
signal_left_rec  <- idwt(wt_left_rec)
signal_right_rec <- idwt(wt_right_rec)

audio_wav <- Wave(
    left = signal_left_rec,
    right = signal_right_rec,
    samp.rate = audio@samp.rate,
    bit = audio@bit
)
writeWave(audio_wav, "data_comp/audio2comp.wav")


mse_left  <- mean((audio@left  - signal_left_rec)^2)
mse_right <- mean((audio@right - signal_right_rec)^2)

cat("MSE Left :", mse_left, "\n")
cat("MSE Right:", mse_right, "\n")

```
```{r}
plot_heatmap_wavelet_coef(audio,n.levels,lambda,threshold=F)
plot_heatmap_wavelet_coef(audio,n.levels,lambda,threshold=T)
```


```{r}
plot_energy_vs_coeff(audio,n.levels,lambda)
```
```{r}
lambda_vals <- seq(0, 1, by = 0.1)

size_data <- size_vs_lambda(
  audio     = audio,
  n.levels  = n.levels,
  lambda_vals = lambda_vals
)

plot(
  red_data$redundancy,
  size_data$size_bytes/max(size_data$size_bytes),
  type = "b", pch = 19,
  col = "darkred",
  xlab = "Redundancia",
  ylab = "Porcentaje de archivo comprimido",
  main = "Porcentaje de archivo comprimido vs redundancia"
)

grid()

```
## Redundancia de la señal

Escribimos la redundancia de la señal como:

$$R(\lambda)=1-\frac{H(\lambda)}{H_{max}(\lambda)}$$
Donde $H(\lambda)$ es la entropía de los coeficientes wavelet tras el threshold y $H_{max}$ es la entropía máxima posible. En este caso una redundancia alta significa que la señal está formada por pocos símbolos que dominan (muchos ceros y pocos valores no nulos), por lo tanto, una alta redundancia significa que la información está muy estructurada. 

El valor de la redundancia va a permitir elegir el valor de $\lambda$ óptimo, este valor busca el máximo de redundancia sin degradar la señal. El objetivo es eliminar la redundancia estadística sin pérdida perceptual ni estructural relevante.


```{r}
red_data <- redundancy_vs_lambda(
  audio,
  n.levels,
  lambda_vals = seq(0, 1, 0.1)
)
plot(
  red_data$lambda,
  red_data$redundancy,
  type = "b", pch = 19,
  col = "darkgreen",
  xlab = expression(lambda),
  ylab = "Redundancia",
  main = "Redundancia de la señal wavelet vs umbral"
)

grid()

```

