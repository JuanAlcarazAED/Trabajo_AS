---
title: "Compresión del audio"
author: "Javier Herrero Pérez"
date: "2025-12-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Compresión del audio

## Separar audio y video

```{r}
# Librerías
library(av)

library(wavelets)
library(tuneR)

library(tuneR)
library(dplyr)
library(ggplot2)
```




```{r}
av_audio_convert("data/video.mp4", "data/audio.wav")
frames<-av_video_images("data/video.mp4", destdir = "data/frames", fps = 30)
```
```{r}
```


```{r}
audio <- readWave("data/audio.wav")

```

```{r}
plot(audio)  
```


```{r}
signal<-as.numeric(audio@left)
```

Cosas que tengo pensadas hacer:
- Calcular la energía en función de las wavelets 
- Representar los niveles de la wavlet, los coeficientes y el tiempo tick
- Representar las ondas con el threshold tick
- Normalizar los valores

```{r}
# Página que voy a usar de referencia
#https://stackoverflow.com/questions/36756500/visualization-of-wavelets-coefficients-for-different-deconstruction-levels 
# Apuntes del tema 3 de compresión de una onda

# Funciones importantes

expand_to_length <- function(coefs, target_len) {
rep_each <- ceiling(target_len / length(coefs))
expanded <- rep(coefs, each = rep_each)
expanded[1:target_len]
}
hard_threshold <- function(coefs, lambda) {
  coefs[log(1+abs(coefs)**2) < lambda*max(log(1+abs(coefs)**2))] <- 0
  return(coefs)
}

plot_heatmap_wavelet_coef<-function(wt,L,n.levels){
  coef_list <- lapply(1:n.levels, function(i) {
    expanded <- expand_to_length(wt@W[[i]], L)
    log1p(abs(expanded)^2)
  })
  coef_matrix_raw <- do.call(cbind, coef_list)
  coef_matrix <- (coef_matrix_raw[, 1:n.levels])
  
  colores <- brewer.pal(9, "YlOrBr")
  
  image(x=1:L,y=1:n.levels,z=(coef_matrix),main="Wavelet coeficientes de detalle heatmap",xlab="Tiempo",ylab="Nivel wavelet",yaxt="n")
  axis(side=2,at=1:n.levels,labels = paste0("d", 1:n.levels))
}

#Parámetros y valores

L <- length(signal)
n.levels <- 8
wt <- dwt(signal, filter = "la8", n.levels = n.levels)
lambda <- 0.8
wt_thresholded <- wt 
wt_thresholded@W <- lapply(wt@W, function(W_i) {hard_threshold(W_i, lambda)})


# Representaciones

plot_heatmap_wavelet_coef(wt,L,n.levels)
plot_heatmap_wavelet_coef(wt_thresholded,L,n.levels)

```
```{r}

#n.levels
for (i in 1:n.levels) {
  # vector de coeficientes
  coefs <- wt@W[[i]]
  
  # Establecer límites para todos los gráficos
  
  y_lim <- max(abs(unlist(coefs))) * (1+lambda)
  
  # Trazar los coeficientes
  plot(coefs, 
  type = 'l',
  main = paste("Nivel de Detalle d",i),
  xlab = "Índice del Coeficiente",
  ylab = expression(w[i]), 
  ylim = c(-y_lim, y_lim), # Usar el límite Y calculado
  col = "darkgray"
  )
  
  points(x = which(log(1+abs(coefs)**2) >= lambda*max(log(1+abs(coefs)**2))), 
  y = coefs[log(1+abs(coefs)**2) >= lambda*max(log(1+abs(coefs)**2))], 
  col = "blue", 
  pch = 19, 
  cex = 0.5)
}


```






