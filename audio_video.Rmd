---
title: "Compresión del audio"
author: "Javier Herrero Pérez"
date: "2025-12-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Compresión del audio

## Separar audio y video

```{r}
# Librerías
library(av)

library(wavelets)
library(tuneR)

library(RColorBrewer)
```




```{r}
av_audio_convert("data/video.mp4", "data/audio.wav")
frames<-av_video_images("data/video.mp4", destdir = "data/frames", fps = 30)
```
```{r}
```


```{r}
audio <- readWave("data/audio.wav")

```

```{r}
plot(audio)  
```


```{r}
signal<-as.numeric(audio@left)
```

Cosas que tengo pensadas hacer:
- Calcular la energía en función de las wavelets 
- Representar los niveles de la wavlet, los coeficientes y el tiempo tick
- Representar las ondas con el threshold tick
- Normalizar los valores

```{r}
# Página que voy a usar de referencia
#https://stackoverflow.com/questions/36756500/visualization-of-wavelets-coefficients-for-different-deconstruction-levels 
# Apuntes del tema 3 de compresión de una onda

# Funciones importantes

expand_to_length <- function(coefs, target_len) {
rep_each <- ceiling(target_len / length(coefs))
expanded <- rep(coefs, each = rep_each)
expanded[1:target_len]
}
hard_threshold <- function(coefs, lambda) {
  power<-log(1+abs(coefs)**2)
  coefs[power < lambda*max(power)] <- 0
  return(coefs)
}

plot_heatmap_wavelet_coef<-function(wt,L,n.levels){
  coef_list <- lapply(1:n.levels, function(i) {
    expanded <- expand_to_length(wt@W[[i]], L)
    log1p(abs(expanded)^2)
  })
  coef_matrix_raw <- do.call(cbind, coef_list)
  coef_matrix <- (coef_matrix_raw[, 1:n.levels])
  
  colores <- brewer.pal(9, "YlOrBr")
  
  image(x=1:L,y=1:n.levels,z=(coef_matrix),main="Wavelet coeficientes de detalle heatmap",xlab="Tiempo",ylab="Nivel wavelet",yaxt="n")
  axis(side=2,at=1:n.levels,labels = paste0("d", 1:n.levels))
}


plot_umbralD<-function(wt,i,lambda){
  # Coeficientes del nivel i
  coefs <- wt@W[[i]]
  
  # Energía logarítmica (solo la calculamos una vez)
  power <- log1p(abs(coefs)^2)
  
  # Umbral relativo
  umbral <- lambda * max(power)
  
  # Índices que superan el umbral
  idx_keep <- which(power >= umbral)
  
  # Límite vertical para el plot
  y_lim <- 1.1 * max(abs(coefs))
  
  # Grafica
  plot(
    coefs, type = 'l',
    main = paste("Nivel de Detalle d", i),
    xlab = "Índice del Coeficiente",
    ylab = bquote(w[.(i)]),
    ylim = c(-y_lim, y_lim),
    col = "darkgray"
  )
  
  # Añadimos puntos thresholded
  points(
    x = idx_keep,
    y = coefs[idx_keep],
    col = "blue",
    pch = 19,
    cex = 0.6
  )
}

plot_energy_vs_coeff<-function(wt,wt_thresholded){
  all_coefs <- unlist(wt@W)
  energies <- abs(all_coefs)^2
  # Ordenar por energía descendente
  ord <- order(energies, decreasing = TRUE)
  coefs_sorted <- all_coefs[ord]
  energies_sorted <- energies[ord]
  # Energía total
  E_total <- sum(energies_sorted)
  
  E_cum <- cumsum(energies_sorted)
  
  # Porcentaje de energía
  percent_energy <- E_cum / E_total * 100
  
  # Número de coeficientes preservados
  k_vals <- 1:length(all_coefs)
  
  plot(k_vals, percent_energy,
       type = "l",
       col = "darkorange",
       lwd = 2,
       xlab = "Número de coeficientes preservados",
       ylab = "Energía capturada (%)",
       main = "Curva energía capturada vs coeficientes preservados")
  coefs_keep <- sum(unlist(lapply(wt_thresholded@W, function(v) v != 0)))
  
  # Porcentaje correspondiente
  energy_keep <- percent_energy[coefs_keep]
  
  points(coefs_keep, energy_keep, pch = 19, col = "blue", cex = 1.3)
  text(coefs_keep, energy_keep, labels = " umbral", pos = 4)
  grid()
  }


```




```{r}
lambda <- 0.7
n.levels <- 2


L <- length(signal)
wt <- dwt(signal, filter = "la8", n.levels = n.levels)
wt_thresholded <- wt 
wt_thresholded@W <- lapply(wt@W, function(W_i) {hard_threshold(W_i, lambda)})

```


```{r}
plot_heatmap_wavelet_coef(wt,L,n.levels)
plot_heatmap_wavelet_coef(wt_thresholded,L,n.levels)


for (i in 1:n.levels){
plot_umbralD(wt,i,lambda)
}

plot_energy_vs_coeff(wt,wt_thresholded)
```



Los puntos azules son los que sobreviven a la compresión, todo lo gris se elimina



## Comprimir el audio 


```{r}

signal_compressed <- idwt(wt_thresholded)
compressed_audio <- Wave(left = signal_compressed,
                         right=signal_compressed, # Habría que hacer la compresión también para la izqueirda y comprobar si es monocanal
                         samp.rate = audio@samp.rate,
                         bit = audio@bit)

writeWave(compressed_audio, "data_comp/audio_comp.wav")

# Reduce el tamaño pero utilizando mp3 no con todo lo que he hecho
#av_audio_convert("data_comp/audio_comp.wav",output = "data_comp/audio_comp.mp3")
error <- signal - signal_compressed
RMSE <- sqrt(mean(error^2))

RMSE
print(sqrt(mean(signal^2)))

```

567

```{r}
coefs_original  <- unlist(wt@W)
coefs_compressed <- unlist(wt_thresholded@W)

n_original  <- length(coefs_original)
n_kept      <- sum(coefs_compressed != 0)

compression_ratio <- n_kept/n_original
compression_ratio
```

```{r}
total_coefs <- 0
zero_coefs <- 0

# W contiene los coeficientes de detalle
for (W_i in wt_thresholded@W) {
    total_coefs <- total_coefs + length(W_i)
    zero_coefs <- zero_coefs + sum(W_i == 0)
}

V_final <- wt_thresholded@V[[n.levels]]
total_coefs <- total_coefs + length(V_final)
zero_coefs <- zero_coefs + sum(V_final == 0)

sparsity_ratio <- zero_coefs / total_coefs

cat(sprintf("Coeficientes Totales: %d\n", total_coefs))
cat(sprintf("Coeficientes Cero: %d\n", zero_coefs))
cat(sprintf("Tasa de Esparsidad (Ahorro Teórico de Datos): %.2f%%\n", sparsity_ratio * 100))
```

```{r}
entropy <- function(x) {
  p <- table(x) / length(x)
  -sum(p * log2(p))
}

bits_original <- audio@bit
H <- entropy(round(wt_thresholded@W$W1))
redundancy <- (bits_original - H) / bits_original
redundancy
```

