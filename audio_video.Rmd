---
title: "Compresión del audio"
author: "Javier Herrero Pérez"
date: "2025-12-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Compresión del audio

## Separar audio y video

```{r}
# Librerías
library(av)
library(wavelets)
library(tuneR)
library(RColorBrewer)
```





```{r}
# Página que voy a usar de referencia
#https://stackoverflow.com/questions/36756500/visualization-of-wavelets-coefficients-for-different-deconstruction-levels 
# Apuntes del tema 3 de compresión de una onda

# Funciones importantes

sep_audio_video<-function(main="data/video.mp4",audio="data/audio.wav",video="data/frames",fps=30){
  # Función para separar imagen de audio
  av_audio_convert(main,audio)
  frames<-av_video_images(main,destdir=video,fps=fps)
}


expand_to_length <- function(coefs, target_len) {
rep_each <- ceiling(target_len / length(coefs))
expanded <- rep(coefs, each = rep_each)
expanded[1:target_len]
}


hard_threshold <- function(coefs, lambda) {
  power<- abs(coefs)**2#log(1+abs(coefs)**2)
  umbral <-lambda*max(power)
  coefs[power <= umbral] <- 0
  return(coefs)
}
hard_threshold2 <- function(coefs, lambda) {
  power<- log(1+abs(coefs)**2)
  umbral <-lambda*max(power)
  coefs[power <= umbral] <- 0
  return(coefs)
}

plot_heatmap_wavelet_coef2<-function(audio,n.levels,lambda,plot="left",threshold=F){
  # Señales
  signal_left  <- as.numeric(audio@left)
  signal_right <- as.numeric(audio@right)
  L <- length(signal_left)
  
  # DWT sin umbralizar
  wt_left  <- dwt(signal_left,  filter = "la8", n.levels = n.levels)
  wt_right <- dwt(signal_right, filter = "la8", n.levels = n.levels)
  
  # DWT umbralizado para visualización log
  wt_thr_left  <- wt_left
  wt_thr_right <- wt_right
  
  wt_thr_left@W  <- lapply(wt_left@W,  hard_threshold2, lambda = lambda)
  wt_thr_right@W <- lapply(wt_right@W, hard_threshold2, lambda = lambda)
  
  # Selección del lado (izquierda/derecha)
  wt <- switch(plot,
               left  = if (!threshold) wt_left  else wt_thr_left,
               right = if (!threshold) wt_right else wt_thr_right)
  
  # Expandimos coeficientes y computamos energía logarítmica
  coef_list <- lapply(1:n.levels, function(i) {
    expanded <- expand_to_length(wt@W[[i]], L)
    log(1 + abs(expanded)^2)
  })
  
  coef_matrix <- do.call(cbind, coef_list)
  
  colores <- brewer.pal(9, "YlOrBr")
  
  image(x=1:L,y=1:n.levels,z=(coef_matrix),main="Wavelet coeficientes de detalle heatmap",xlab="Tiempo",ylab="Nivel wavelet",yaxt="n")
  axis(side=2,at=1:n.levels,labels = paste0("d", 1:n.levels))
}

plot_heatmap_wavelet_coef<-function(audio,n.levels,lambda,plot="left",threshold=F){
  vals<-dwt_values(audio,n.levels,lambda)
  if (threshold==F){
    if (plot=="left"){
      wt<-vals[[1]]
    }
    else{
      wt<-vals[[2]]
    }
  }
  else{
    if (plot=="left"){
      wt<-vals[[3]]
    }
    else{
      wt<-vals[[4]]
    }
    
  }
  L<- length(audio@left)
  
  coef_list <- lapply(1:n.levels, function(i) {
    expanded <- expand_to_length(wt@W[[i]], L)
    abs(expanded)^2
  })
  
  coef_matrix_raw <- do.call(cbind, coef_list)
  coef_matrix <- (coef_matrix_raw[, 1:n.levels])
  
  colores <- brewer.pal(9, "YlOrBr")
  
  image(x=1:L,y=1:n.levels,z=(coef_matrix),main="Wavelet coeficientes de detalle heatmap",xlab="Tiempo",ylab="Nivel wavelet",yaxt="n")
  axis(side=2,at=1:n.levels,labels = paste0("d", 1:n.levels))
}


plot_umbralD<-function(audio,n.levels,lambda,i,plot="left",threshold=F){
  # Coeficientes del nivel i
  vals<-dwt_values(audio,n.levels,lambda)
    if (threshold==F){
    if (plot=="left"){
      wt<-vals[[1]]
    }
    else{
      wt<-vals[[2]]
    }
  }
  else{
    if (plot=="left"){
      wt<-vals[[3]]
    }
    else{
      wt<-vals[[4]]
    }
    
  }
  coefs <- wt@W[[i]]
  
  # Energía logarítmica (solo la calculamos una vez)
  power <- abs(coefs)**2
  # Umbral relativo
  umbral <- lambda * max(power)
  
  # Índices que superan el umbral
  idx_keep <- which(power >= umbral)
  
  # Límite vertical para el plot
  y_lim <- 1.1 * max(abs(coefs))
  
  # Grafica
  plot(
    coefs, type = 'l',
    main = paste("Nivel de Detalle d", i),
    xlab = "Índice del Coeficiente",
    ylab = bquote(w[.(i)]),
    ylim = c(-y_lim, y_lim),
    col = "darkgray"
  )
  
  # Añadimos puntos thresholded
  points(
    x = idx_keep,
    y = coefs[idx_keep],
    col = "blue",
    pch = 19,
    cex = 0.6
  )
}

plot_energy_vs_coeff <- function(audio, n.levels, lambda, plot="left"){
  vals <- dwt_values(audio, n.levels, lambda)
  
  wt  <- if (plot=="left") vals$wt_left  else vals$wt_right
  wtT <- if (plot=="left") vals$thresholded_left else vals$thresholded_right
  
  all_coefs <- unlist(wt@W)
  energies   <- abs(all_coefs)^2
  
  ord <- order(energies, decreasing=TRUE)
  energies_sorted <- energies[ord]
  E_total <- sum(energies_sorted)
  E_cum   <- cumsum(energies_sorted)
  
  percent_energy <- 100 * E_cum / E_total
  k_vals <- seq_along(all_coefs)
  
  plot(k_vals, percent_energy, type="l",
       col="darkorange", lwd=2,
       xlab="Coeficientes preservados",
       ylab="Energía capturada (%)",
       main="Curva energía capturada vs coeficientes preservados")
  
  coefs_keep <- sum(unlist(lapply(wtT@W, function(v) v != 0)))
  
  points(coefs_keep, percent_energy[coefs_keep], 
         pch=19, col="blue", cex=1.3)
  
  text(coefs_keep, percent_energy[coefs_keep],
       labels=" umbral", pos=4)
  
  grid()
}

dwt_values<-function(audio,n.levels,lambda){
  
  signal_left<-as.numeric(audio@left)
  signal_rigth<-as.numeric(audio@right)
  
  wt_left <- dwt(signal_left, filter = "la8", n.levels = n.levels)
  wt_right <- dwt(signal_rigth, filter = "la8", n.levels = n.levels)
  
  wt_thresholded_left <- wt_left 
  wt_thresholded_right <- wt_right 
  
  wt_thresholded_left@W  <- lapply(wt_left@W,  hard_threshold, lambda=lambda)
  wt_thresholded_right@W <- lapply(wt_right@W, hard_threshold, lambda=lambda)
  return(list(
    wt_left  = wt_left,
    wt_right = wt_right,
    thresholded_left  = wt_thresholded_left,
    thresholded_right = wt_thresholded_right
  ))
}


entropy <- function(x) {
  p <- table(x) / length(x)
  -sum(p * log2(p))
}



audio_compress<-function(audio,n.levels,lambda,ruta="data_comp/audio_comp2.wav"){
  vals<-dwt_values(audio,n.levels,lambda)
  
  wt_left  <- vals[[1]]
  wt_right <- vals[[2]]
  thresholded_left  <- vals[[3]]
  thresholded_right <- vals[[4]]
  
  
  # signal_compressed_left <- idwt(thresholded_left)
  # signal_compressed_right <- idwt(thresholded_right)
  signal_compressed_left <- idwt(wt_left)
  signal_compressed_right <- idwt(wt_right)
  
  # Juntar el audio comprimido
  compressed_audio <- Wave(left = signal_compressed_left,
                           right=signal_compressed_right,
                           samp.rate = audio@samp.rate,
                           bit = audio@bit)
  writeWave(compressed_audio, ruta)
}


reconstruir_video <- function(frames_dir = "data/frames",
                              audio_comp = "data_comp/audio_comp.wav",
                              output = "data_comp/video_final.mp4",
                              fps = 30) {
  
  # Creamos un patrón para leer los frames (images)
  frames <- list.files(frames_dir, full.names = TRUE)
  
  # Asegurarnos de que se ordenan en orden numérico
  frames <- frames[order(nchar(frames), frames)]
  
  # Codificar el video a partir de las imágenes y el audio comprimido
  av::av_encode_video(
    input = frames,
    output = output,
    framerate = fps,
    audio = audio_comp
  )
  
}

```


```{r}
audio_compress(audio,n.levels,lambda)
```




```{r}
reconstruir_video()
```






## Análisis 
Separar audio de imagen:
```{r}
sep_audio_video()
```

Parámetros:
```{r}
lambda <- 0.5
n.levels <- 2
audio <- readWave("data/audio.wav")
```


```{r}
source("funciones_audio.R",echo=F)
plot_heatmap_wavelet_coef(audio,n.levels,lambda,threshold=F)
plot_heatmap_wavelet_coef(audio,n.levels,lambda,threshold=T)


for (i in 1:n.levels){
  plot_umbralD(audio,n.levels,lambda,i,plot="left",threshold=F)
}

plot_energy_vs_coeff(audio,n.levels,lambda)
```




```{r}
hard_threshold_energy <- function(coefs, lambda) {
  power <- abs(coefs)^2
  total_energy <- sum(power)
  ord <- order(power)
  cum_energy <- cumsum(power[ord])
  idx <- ord[cum_energy <= lambda * total_energy]
  coefs[idx] <- 0
  coefs
}

dwt_values <- function(audio, n.levels, lambda) {
  
  signal_left  <- as.numeric(audio@left)
  signal_right <- as.numeric(audio@right)
  
  wt_left  <- dwt(signal_left,  filter = "la8", n.levels = n.levels)
  wt_right <- dwt(signal_right, filter = "la8", n.levels = n.levels)
  
  thr_left  <- wt_left
  thr_right <- wt_right
  
  thr_left@W  <- lapply(wt_left@W,  hard_threshold_energy, lambda = lambda)
  thr_right@W <- lapply(wt_right@W, hard_threshold_energy, lambda = lambda)
  
  list(
    wt_left  = wt_left,
    wt_right = wt_right,
    thr_left = thr_left,
    thr_right = thr_right
  )
}

quantize <- function(x, delta) {
  round(x / delta)
}

quantize_wt <- function(wt, delta) {
  wt_q <- wt
  wt_q@W <- lapply(wt@W, quantize, delta = delta)
  wt_q@V[[length(wt@V)]] <- quantize(wt@V[[length(wt@V)]], delta)
  wt_q
}

rle_encode <- function(x) {
  x <- as.vector(x)
  r <- rle(x)
  list(values = r$values, lengths = r$lengths)
}

encode_wt <- function(wt_q) {
  list(
    W = lapply(wt_q@W, rle_encode),
    V = rle_encode(wt_q@V[[length(wt_q@V)]])
  )
}

save_compressed <- function(file, left, right, delta, filter, n.levels) {
  saveRDS(
    list(
      left = left,
      right = right,
      delta = delta,
      filter = filter,
      n.levels = n.levels
    ),
    file = file
  )
  file.info(file)$size
}


rle_decode <- function(enc) {
  inverse.rle(list(values = enc$values, lengths = enc$lengths))
}

decode_wt <- function(enc, template_wt) {
  wt <- template_wt
  
  wt@W <- Map(
    function(e, ref) {
      v <- rle_decode(e)
      matrix(v, nrow = length(v), ncol = ncol(ref))
    },
    enc$W,
    template_wt@W
  )
  
  v <- rle_decode(enc$V)
  wt@V[[length(wt@V)]] <- matrix(
    v,
    nrow = length(v),
    ncol = ncol(template_wt@V[[length(template_wt@V)]])
  )
  
  wt
}


dequantize_wt <- function(wt, delta) {
  wt@W <- lapply(wt@W, function(x) x * delta)
  wt@V[[length(wt@V)]] <- wt@V[[length(wt@V)]] * delta
  wt
}


```

```{r}
# Parámetros
n.levels <- 6
lambda <- 0   # sparsity
delta  <- 1e-1     # cuantización

# DWT + threshold
vals <- dwt_values(audio, n.levels, lambda)

# Cuantización
q_left  <- quantize_wt(vals$thr_left,  delta)
q_right <- quantize_wt(vals$thr_right, delta)

# Codificación
enc_left  <- encode_wt(q_left)
enc_right <- encode_wt(q_right)

# Guardar archivo comprimido
size_bytes <- save_compressed(
  "audio_wavelet_comp.rds",
  left  = enc_left,
  right = enc_right,
  delta = delta,
  filter = "la8",
  n.levels = n.levels
)

cat("Tamaño comprimido:", size_bytes, "bytes\n")

```
187239 
4885757 
3299333 

```{r}
# Decodificar
wt_left_rec <- dequantize_wt(
  decode_wt(enc_left, vals$thr_left),
  delta
)

wt_right_rec <- dequantize_wt(
  decode_wt(enc_right, vals$thr_right),
  delta
)

# Señal final
signal_left_rec  <- idwt(wt_left_rec)
signal_right_rec <- idwt(wt_right_rec)

audio_wav <- Wave(
    left = signal_left_rec,
    right = signal_right_rec,
    samp.rate = audio@samp.rate,
    bit = audio@bit
)
writeWave(audio_wav, "data_comp/audio2comp.wav")


mse_left  <- mean((audio@left  - signal_left_rec)^2)
mse_right <- mean((audio@right - signal_right_rec)^2)

cat("MSE Left :", mse_left, "\n")
cat("MSE Right:", mse_right, "\n")

```

