---
title: "Compresión del audio"
author: "Javier Herrero Pérez"
date: "2025-12-04"
output:
  pdf_document: default
  html_document: default
bibliography: referencias.bib
csl: ieee.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE,warning = FALSE,message = FALSE)
```

# Compresión del audio


```{r}
# Librerías
library(av)
library(wavelets)
library(tuneR)
library(RColorBrewer)
```


```{r}
source("funciones_audio.R",echo=F)
```



```{r}
# Para separar audio-iamgen
#sep_audio_video()
```

La compresión del audio se va a realizar en el dominio wavelet mediante el umbralado selectivo de la energía de los coeficientes. El planteamiento se centra en estudiar la redundancia de la señal, utilizando la entropía de Shannon calculada a partir de la distribución de energías de la señal umbralizada [@mallat2009]. Se busca un equilibrio entre maximizar la redundancia y la compresión del archivo sin perder información relevante.

La compresión se realiza mediante un umbralado global basado en la energía acumulada. Primero se ordenan todos los coeficientes wavelet de mayor a menor energía para identificar su peso en la señal. Posteriormente se define un porcentaje de preservación energética determinado por un valor umbral $\lambda$ y se establecen a cero todos aquellos coeficientes cuya contribución queda por debajo del valor umbral.

La frecuencia de muestreo del audio es de 44100 Hz, dado que cada nivel de descomposición divide el espectro a la mitad, elegir 6 niveles es razonable ya que se llega a cubrir las frecuencias medias y bajas donde se concentra energías. 

```{r}
audio <- readWave("data/audio.wav")
n.levels <- 6
```

El audio a estudiar está en estéreo, la amplitud del audio para ambos canales se puede observar en la siguiente figura.

```{r,dev="png", dpi=300, fig.width=10, fig.height=4}

N <- length(audio@left)
freq <- audio@samp.rate
tiempo <- (0:(N-1)) / freq


par(mfrow = c(1, 2), mar = c(4, 4, 2, 1)) 


plot(tiempo, audio@left, type = "l",
     main = "Canal Izquierdo",
     xlab = "Tiempo (segundos)", ylab = "Amplitud")


plot(tiempo, audio@right, type = "l",
     main = "Canal Derecho",
     xlab = "Tiempo (segundos)", ylab = "")

par(mfrow = c(1, 1))
```

El parámetro fundamental en este estudio es la energía, definida como la amplitud al cuadrado de la señal. En la siguiente figura se representa la energía de la señal, donde se observa que ambos canales presentan picos pronunciados. Esta concentración de energía indica una baja entropía, mientras que una distribución de energía uniforme dificultaría la compresión. Una señal con picos de energía concentrado permite un umbralado más eficiente en el dominio wavelet.

```{r,dev="png", dpi=300, fig.width=10, fig.height=4}

N <- length(audio@left)
freq <- audio@samp.rate
tiempo <- (0:(N-1)) / freq


par(mfrow = c(1, 2), mar = c(4, 4, 2, 1)) 


plot(tiempo, (audio@left)^2, type = "l",
     main = "Canal Izquierdo",
     xlab = "Tiempo (segundos)", ylab = "Energía")


plot(tiempo, (audio@right)^2, type = "l",
     main = "Canal Derecho",
     xlab = "Tiempo (segundos)", ylab = "")

par(mfrow = c(1, 1))

```


## Redundancia de la señal


La compresión de una señal mediante umbralizado de energía en el dominio wavelet busca concentrar la energía de la señal en un número reducido de coeficientes, eliminando aquellos que aportan poca contribución energética. Este proceso modifica la distribución estadística de la energía, haciendo que esta se concentre en menos estados. Como consecuencia la señal resultante presenta una distribución menos uniforme, lo que conlleva a una reducción de la entropía.

Para analizar de forma cuantitativa este efecto, se estudia la entropía de Shannon asociada a la distribución de energía de los coeficientes wavelet tras haber umbralizado. La entropía se calcula a partir del histograma de energías, en el que cada bin representa un simbolo discreto. De esta forma se puede medir de manera robusta el grado de concentración energética dado por el parámetro umbral $\lambda$. Con el fin de normalizar la magnitud se introduce el concepto de redundancia definida como:

$$R(\lambda)=1-\frac{H(\lambda)}{H_{max}}$$

Donde $H(\lambda)$ es la entropía de la distribución de energía de los coeficientes wavelet tras umbralizar y $H_{max}=\log_2(N_{bins})$ con $N_{bins}$ el número de bins que se mantiene constante para todos los valores de $\lambda$. Una redundancia elevada indica que la entropía de la señal está concentrada en un número reducido de estados, lo que indica que la señal presenta una alta compresibilidad. 


```{r}
# red_data <- redundancy_vs_lambda(
#   audio,
#   n.levels,
#   lambda_vals = seq(0, 1, 0.1)
# )
# plot(
#   red_data$lambda,
#   red_data$redundancy,
#   type = "b", pch = 19,
#   col = "darkgreen",
#   xlab = expression(lambda),
#   ylab = "Redundancia",
#   main = "Redundancia de la señal wavelet vs umbral"
# )
# 
# grid()
```

Se ha seleccionado el formato `.rds` para el análisis del almacenamiento debido a su capacidad para preservar la estructura de los coeficientes wavelet, incluyendo los valores nulos generados por el umbralado. A diferencia del formato `.wav`, que almacena la señal reconstruida en el dominio temporal sin tener en cuenta la presencia de ceros. 
El porcentaje de archivo comprimido se calcula como el tamaño relativo del archivo `.rds` normalizado respecto al tamaño máximo obtenido para $\lambda=0$, correspondiene al caso sin compresión. De esta manera, esta magnitud refleja la reducción de información estructural debida al umbralado.

Para buscar el mejor valor umbral se va a buscar aquel valor que tiene una alta reducción del archivo maximizando el valor de la redundancia sin eliminar información relevante. En la siguiente figura se representa el porcentaje de archivo comprimido frente a la redundancia de la señal wavelet.

```{r,fig.width=6, fig.height=4}
lambda_vals <- seq(0, 1, by = 0.1)
lambda_vals_2<-seq(0, 0.3, by = 0.1)
red_data <- redundancy_vs_lambda(
  audio,
  n.levels,
  lambda_vals = lambda_vals
)

size_data <- size_vs_lambda(
  audio     = audio,
  n.levels  = n.levels,
  lambda_vals = lambda_vals
)

plot(
  red_data$redundancy,
  size_data$size_bytes/max(size_data$size_bytes),
  type = "b", pch = 19,
  col = "darkred",
  xlab = "Redundancia",
  ylab = "Porcentaje de archivo comprimido",
  main = "Porcentaje de archivo comprimido vs redundancia"
)
text(
  red_data$redundancy[1:3],
  (size_data$size_bytes / max(size_data$size_bytes))[1:3],
  labels = paste0(expression(lambda =), lambda_vals[1:3]),
  pos = 4,
  cex = 0.75
)
grid()

```

Se observa que el valor óptimo, que logra un equilibrio entre una alta redundancia y la preservación de la información de la señal, corresponde a un umbral de $\lambda=0.1$. Por tanto, este será el valor utilizado para la compresión definitiva del audio.


## Análisis de la señal comprimida


```{r}
# Parámetros
lambda <- 0.1

# DWT + threshold
vals <- dwt_values(audio, n.levels, lambda)

q_left  <- vals$thr_left
q_right <- vals$thr_right

# Codificación
enc_left  <- encode_wt(q_left)
enc_right <- encode_wt(q_right)

# Guardar archivo comprimido
size_bytes <- save_compressed(
  "data_comp/audio_wavelet_comp.rds",
  left  = enc_left,
  right = enc_right,
  filter = "la8",
  n.levels = n.levels
)

#cat("Tamaño del archivo comprimido:", size_bytes/1024, "KB\n")

```

El mapa de calor de los coeficientes de detalle permite visualizar la distribución de la energía de la señal a través de las seis escalas wavelet. Las áreas en rojo representan coeficientes con valores cercanos a cero, mientras que las zonas amarillas y blancas indican la presencia de componentes de alta energía. Tras aplicar el umbral se observa una escasez estructural, especialmente en los niveles más finos $d_1$ y $d_2$. En la siguiente figura se ha representado únicamente el canal izquierdo por simplicidad, pero sería análogo con el canal derecho.

```{r,dev="png", dpi=300, fig.width=10, fig.height=4}
par(mfrow = c(1, 2))
plot_heatmap_wavelet_coef(audio,n.levels,lambda,threshold=F)
plot_heatmap_wavelet_coef(audio,n.levels,lambda,threshold=T)
par(mfrow = c(1, 1))
```

Se ha aplicado una función de expansión para compensar el submuestreo intrínseco de la DWT, donde los niveles más profundos como $d_6$ contienen menos coeficientes que los niveles finos. Permite alinear todas las escalas con la longitud original de la señal, facilitando una comparación visual directa de la energía en cada instante de tiempo.

```{r,fig.width=6, fig.height=4}
plot_energy_vs_coeff(audio,n.levels,lambda)
```

En la representación de la energía capturada frente a coeficientes se observa que una fracción mínima de los coeficientes logra capturar el $90\%$ de la energía total del audio, en torno a los 25000 primeros coeficientes. Esto permite eliminar la gran mayoría de los coeficientes con menor energía sin generar una pérdida de información significativa.



```{r}

wt_left_rec <- decode_wt(enc_left, vals$thr_left)

wt_right_rec <- decode_wt(enc_right, vals$thr_right)

# Señal final
signal_left_rec  <- idwt(wt_left_rec)
signal_right_rec <- idwt(wt_right_rec)

audio_wav <- Wave(
    left = signal_left_rec,
    right = signal_right_rec,
    samp.rate = audio@samp.rate,
    bit = audio@bit
)
writeWave(audio_wav, "data_comp/audio2comp.wav")


mse_left  <- sqrt(mean((audio@left - signal_left_rec)^2)) /sqrt(mean(audio@left^2))
mse_right <- sqrt(mean((audio@right - signal_right_rec)^2))/sqrt(mean(audio@right^2))

# cat("NRMSE Left :", mse_left, "\n")
# cat("NRMSE Right:", mse_right, "\n")

```

Para ver el efecto de la señal comprimida se va a comprar la amplitud de la señal original (rojo) y la señal comprimida (negro). A pesar de haber eliminado solo un $10\%$ de la energía hay un efecto importante en la señal como se puede ver en la figura.

```{r,dev="png", dpi=300, fig.width=10, fig.height=4}
audio_comp <- readWave("data_comp/audio2comp.wav")


N <- length(audio_comp@left)
freq <- audio_comp@samp.rate

tiempo <- (0:(N-1)) / freq


par(mfrow = c(1, 2), mar = c(4, 4, 2, 1)) 


plot(tiempo,audio@left,type="l",col="red",main = "Canal Izquierdo",xlab = "Tiempo (segundos)", ylab = "Amplitud")
lines(tiempo, audio_comp@left, type = "l", col = "black")


plot(tiempo,audio@right,type="l",col="red",main = "Canal Derecho",xlab = "Tiempo (segundos)", ylab = "")
lines(tiempo, audio_comp@right, type = "l", col = "black")

par(mfrow = c(1, 1))
```

Para el valor de $\lambda=0.1$ el error cuadrático medio normalizado tras comprimir en el canal izquierdo es `r mse_left` y para el canal derecho `r mse_right`. Esto indica una pérdida apreciable pero concentrada en coeficientes de baja energía, manteniendo una estructura perceptualmente reconocible de la señal.