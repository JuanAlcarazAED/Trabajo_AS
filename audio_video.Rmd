---
title: "Compresión del audio"
author: "Javier Herrero Pérez"
date: "2025-12-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Compresión del audio


```{r}
# Librerías
library(av)
library(wavelets)
library(tuneR)
library(RColorBrewer)
```


```{r}
source("funciones_audio.R",echo=F)
```



```{r}
sep_audio_video()
```

La compresión del audio se ha realizado en el dominio wavelet mediante el umbralado selectivo de la energía de los coeficientes. El planteamiento se centra en estudiar la redundancia de la señal, utilizando la entropía de Shannon calculada a partir de la distribución de energías de la señal aplicada el umbral. Se busca un equilibrio entre reducir la redundancia y la compresión del archivo, eliminando componentes sin afectar a la integridad estructural de la señal.

La compresión se realiza mediante un umbralado global basado en la energía acumulada. Primero se ordenan todos los coeficientes wavelet de mayor a menor energía para identificar su peso en la señal. Posteriormente se define un porcentaje de preservación energética determinado por un valor umbral $\lambda$ y se establecen a cero todos aquellos coeficientes cuya contribución queda por debajo del valor umbral.

La frecuencia de muestreo del auido es de 44100 Hz, dado que cada nivel de descomposición divide el espectro a la mitad, elegir 6 niveles es razonable ya que se llega a cubrir las frecuencias medias y bajas donde se concentra energías. 

```{r}
audio <- readWave("data/audio.wav")
n.levels <- 6
```

El audio a estudiar es estéreo, la amplitud del audio para ambos canales se puede observar en la siguiente figura.

```{r}
N <- length(audio@left)
freq <- audio@samp.rate
tiempo <- (0:(N-1)) / freq


par(mfrow = c(2, 1), mar = c(4, 4, 2, 1)) 


plot(tiempo, audio@left, type = "l",
     main = "Canal Izquierdo",
     xlab = "", ylab = "Amplitud")


plot(tiempo, audio@right, type = "l",
     main = "Canal Derecho",
     xlab = "Tiempo (segundos)", ylab = "Amplitud")

par(mfrow = c(1, 1))
```

El parámetro fundamental en este estudio es la energía, definida como la amplitud al cuadrado de la señal. En la siguiente figura se representa la energía de la señal, donde se observa que ambos canales presentan picos pronunciados. Esta concentración de energía indica una baja entropía, mientras que una distribución de energía uniforme dificultaría la compresión, una señal con picos de energía concentrado permite un umbralado más eficiente en el dominio wavelet.

```{r}

N <- length(audio@left)
freq <- audio@samp.rate
tiempo <- (0:(N-1)) / freq


par(mfrow = c(2, 1), mar = c(4, 4, 2, 1)) 


plot(tiempo, (audio@left)^2, type = "l",
     main = "Canal Izquierdo",
     xlab = "", ylab = "Energía")


plot(tiempo, (audio@right)^2, type = "l",
     main = "Canal Derecho",
     xlab = "Tiempo (segundos)", ylab = "Energía")

par(mfrow = c(1, 1))

```


## Redundancia de la señal


La compresión de una señal mediante umbralizado de energía en el dominio wavelet busca concentrar la energía de la señal en un número reducido de coeficientes, eliminando aquellos que aportan poca contribución energética. Este proceso modifica la distribución estadística de la energía, haciendo que esta se concentre en menos estados. Como consecuencia la señal resultante presenta una distribución menos uniforme, lo que conlleva a una reducción de la entropía.

Para analizar de forma cuantitativa este efecto, se estudia la entropía de Shannon asociada a la distribución de energía de los coeficientes wavelet tras haber umbralizado. La entropía se calcula a partir del histograma de energías, en el que cada bin representa un simbolo discreto. De esta forma se puede medir de manera robusta el grado de concentración energética dado por el parámetro umbral $\lambda$. Con el fin de normalizar la magnitud se introduce el concepto de redundancia definida como:

$$R(\lambda)=1-\frac{H(\lambda)}{H_{max}}$$

Donde $H(\lambda)$ es la entropía de la distribución de energía de los coeficientes wavelet tras umbralizar y $H_{max}=\log_2(N_{bins})$. Una redundancia elevada indica que la entropía de la señal está concentrada en un número reducido de estados, lo que indica que la señal presenta una alta compresibilidad. El análisis de la redundancia en función del parámetro $\lambda$ eprmite identificar el régimen en el que se elimina principalmente la redundancia estadística sin introducir una degradación significativa a la señal.


```{r}
# red_data <- redundancy_vs_lambda(
#   audio,
#   n.levels,
#   lambda_vals = seq(0, 1, 0.1)
# )
# plot(
#   red_data$lambda,
#   red_data$redundancy,
#   type = "b", pch = 19,
#   col = "darkgreen",
#   xlab = expression(lambda),
#   ylab = "Redundancia",
#   main = "Redundancia de la señal wavelet vs umbral"
# )
# 
# grid()
```

## Tamaño del archivo

El objetivo principal es encontrar la máxima tasa de compresión con la menor pérdida de información posible. En la siguiente figura se representa el porcentaje de reducción del archivo en memoria frente a su redundancia. 

```{r}
lambda_vals <- seq(0, 1, by = 0.1)

size_data <- size_vs_lambda(
  audio     = audio,
  n.levels  = n.levels,
  lambda_vals = lambda_vals
)

plot(
  red_data$redundancy,
  size_data$size_bytes/max(size_data$size_bytes),
  type = "b", pch = 19,
  col = "darkred",
  xlab = "Redundancia",
  ylab = "Porcentaje de archivo comprimido",
  main = "Porcentaje de archivo comprimido vs redundancia"
)

grid()

```

Se observa que el valor óptimo, que logra un equilibrio entre una alta redundancia y la preservación de la información de la señal, corresponde a un umbral de $\lambda=0.1$. Por tanto, este será el valor utilizado para la compresión definitiva del audio.


## Análisis de la señal comprimida

Se ha seleccionado el formato .rds para el análisis de almacenamiento debido a su capacidad de contabilizar de manera eficiente los coeficientes nulos generados por el umbralado, una característica de la que carece el formato estándar .wav

```{r}
# Parámetros
lambda <- 0.1

# DWT + threshold
vals <- dwt_values(audio, n.levels, lambda)

q_left  <- vals$thr_left
q_right <- vals$thr_right

# Codificación
enc_left  <- encode_wt(q_left)
enc_right <- encode_wt(q_right)

# Guardar archivo comprimido
size_bytes <- save_compressed(
  "data_comp/audio_wavelet_comp.rds",
  left  = enc_left,
  right = enc_right,
  filter = "la8",
  n.levels = n.levels
)

#cat("Tamaño del archivo comprimido:", size_bytes/1024, "KB\n")

```

El mapa de calor de los coeficientes de detalle permite visualizar la distribución de la energía de la señal a través de las seis escalas wavelet. Las áreas en rojo representan coeficientes con valores cercanos a cero, mientras que las zonas amarillas y blancas indican la presencia de componentes de alta energía. Tras aplicar el umbral se observa una escasez estructural, especialmente en los niveles más finos $d_1$ y $d_2$.

```{r}
plot_heatmap_wavelet_coef(audio,n.levels,lambda,threshold=F)
plot_heatmap_wavelet_coef(audio,n.levels,lambda,threshold=T)
```

Se ha aplicado una función de expansión para compensar el submuestreo intrínseco de la DWT, donde los niveles más profundos como $d_6$ contienen menos coeficientes que los niveles finos. Esta replicación alinea todas las escalas con la longitud original de la señal, permitiendo una comparación visual directa de la energía en cada instante de tiempo.

```{r}
plot_energy_vs_coeff(audio,n.levels,lambda)
```

En la representación de la energía capturada frente a coeficientes se observa que una fracción mínima de los coeficienteslogra capturar el $90\%$ de la energía total del audio. Esto permite eliminar la gran mayoría de los coeficientes con menor energía sin generar una pérdida de información significativa.



```{r}

wt_left_rec <- decode_wt(enc_left, vals$thr_left)

wt_right_rec <- decode_wt(enc_right, vals$thr_right)

# Señal final
signal_left_rec  <- idwt(wt_left_rec)
signal_right_rec <- idwt(wt_right_rec)

audio_wav <- Wave(
    left = signal_left_rec,
    right = signal_right_rec,
    samp.rate = audio@samp.rate,
    bit = audio@bit
)
writeWave(audio_wav, "data_comp/audio2comp.wav")


mse_left  <- mean((audio@left  - signal_left_rec)^2)
mse_right <- mean((audio@right - signal_right_rec)^2)

cat("MSE Left :", mse_left, "\n")
cat("MSE Right:", mse_right, "\n")

```

Para ver el efecto de la señal comprimida se va a comprar la amplitud de la señal original (rojo) y la señal comprimida (negro). A pesar de haber eliminado solo un $10\%$ de la energía hay un efecto importante en la señal como se puede ver en la figura.

```{r}
audio_comp <- readWave("data_comp/audio2comp.wav")


N <- length(audio_comp@left)
freq <- audio_comp@samp.rate

tiempo <- (0:(N-1)) / freq


par(mfrow = c(2, 1), mar = c(4, 4, 2, 1)) 


plot(tiempo,audio@left,type="l",col="red",main = "Canal Izquierdo",xlab = "", ylab = "Amplitud")
lines(tiempo, audio_comp@left, type = "l", col = "black")


plot(tiempo,audio@right,type="l",col="red",main = "Canal Derecho",xlab = "Tiempo (segundos)", ylab = "Amplitud")
lines(tiempo, audio_comp@right, type = "l", col = "black")

par(mfrow = c(1, 1))
```

